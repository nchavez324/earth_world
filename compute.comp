#version 430

layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout(std430) buffer VertexBuffer {
  vec3 positions[];
};
uniform uint VerticesPerEdge;

void main() {
  if (gl_GlobalInvocationID.x >= VerticesPerEdge ||
      gl_GlobalInvocationID.y >= VerticesPerEdge ||
      gl_GlobalInvocationID.z >= 6) {
    return;
  }
  vec3 normal = vec3(0, 0, 0);
  switch (gl_GlobalInvocationID.z) {
  case 0: normal = vec3(+1, 0, 0); break;
  case 1: normal = vec3(-1, 0, 0); break;
  case 2: normal = vec3(0, +1, 0); break;
  case 3: normal = vec3(0, -1, 0); break;
  case 4: normal = vec3(0, 0, -1); break;
  case 5: normal = vec3(0, 0, +1); break;
  }
  vec3 axis1 = vec3(normal.y, normal.z, normal.x);
  vec3 axis2 = cross(axis1, normal);
  vec3 faceOrigin = normal - axis1 - axis2;

  uint vertexIndex =
      (VerticesPerEdge * VerticesPerEdge * gl_GlobalInvocationID.z) +
      (VerticesPerEdge * gl_GlobalInvocationID.y) +
      gl_GlobalInvocationID.x;  
  float patchSize = 2.0 / (VerticesPerEdge - 1);
  vec3 cubePos = faceOrigin + (gl_GlobalInvocationID.x * patchSize * axis1) + (gl_GlobalInvocationID.y * patchSize * axis2);
  vec3 cubePos2 = vec3(
    pow(cubePos.x, 2),
    pow(cubePos.y, 2),
    pow(cubePos.z, 2));
  vec3 spherePosition = vec3(
    cubePos.x * sqrt(1 - cubePos2.y/2 - cubePos2.z/2 + cubePos2.y*cubePos2.z/3),
    cubePos.y * sqrt(1 - cubePos2.z/2 - cubePos2.x/2 + cubePos2.z*cubePos2.x/3),
    cubePos.z * sqrt(1 - cubePos2.x/2 - cubePos2.y/2 + cubePos2.x*cubePos2.y/3));
  positions[vertexIndex] = spherePosition;
}
